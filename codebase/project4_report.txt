1. Basic information
Team number (e.g., 01) : 42
#1 Student ID : 77642095
#1 Student Name : Sahil Bansal
#2 Student ID : 
#2 Student Name : 
OS (bit) : Linux 64 Bit
gcc version : 6.3.0


2. Catalog information about Index
- Show your catalog information about an index (tables, columns).
Index Table is created with 3 columns - table-name, index-name and attribute-name to store information about the indexes created
tables - catalog table contains the Index Table entry
columns - catalog table contains the information about 3 columns of Index table namely table-name, index-name and attribute-name


3. Block Nested Loop Join (If you have implemented this feature)
- Describe how your block nested loop join works (especially, how you manage the given buffers.)
I have implemented the Block Nested Loop Join as follows:
I have created a data structure which gets filled till the size of the elements inside it reaches the limit of number_of_pages*PAGE_SIZE by adding the records from the left page. Now all the records on the right are compared and matched and merged if they match and sent. Whenever we reach the end of right iterator, we free the current block and load the next set of records and repeat the above process.


4. Index Nested Loop Join (If you have implemented this feature)
Yes, I have implemented INL join. For each left record, I set the iterator of right and if there is a match, I send the merged result till I reached the end of left record iterator.


5. Grace Hash Join (If you have implemented this feature)
- Describe how your grace hash join works (especially, in-memory structure).
Yes, I implemented but due to some bug, I have commented out the code. The way I did it was to create n files which is equal to the given number of partitions and then iterate over all left records and based on the hash value on the attribute, will insert it into one of the files. Same was repeated for right records. Now, I get all the records from 1st left partition in the memory and compare the records of the 1st partition of the right. We repeat this step till all partitions are compared.


6. Aggregation
- Describe how your aggregation (basic, group-based hash) works.
I have just implemented the basic aggregation.
I have maintained 4 variables - min, max, count and sum. I iterate over all the records and based on the aggregation operation, will keep on updating one or more of these variables. For average, I update the sum as well as count variable. And once I have iterated, I send the results stored in these variables based on the aggregation operation. For example, if the aggregation operation is MIN, then I will return the min value.

7. Implementation Detail
- Have you added your own source file (.cc or .h)?
No
- Have you implemented any optional features? Then, describe them here.
No
- Other implementation details:
No

6. Other (optional)
- Freely use this section to tell us about things that are related to the project 4, but not related to the other sections (optional)

